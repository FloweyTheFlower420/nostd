// vim: set ft=cpp:
#ifndef __NOSTDLIB_ALGORITHM_H__
#define __NOSTDLIB_ALGORITHM_H__
#include <iterator>
#include <utility>

namespace std
{
    template <typename It, typename F>
    constexpr F for_each(It first, It last, F f)
    {
        for (; first != last; ++first)
            f(*first);
        return f;
    }

    template <typename It, typename S, typename F>
    constexpr It for_each_n(It first, S n, F f)
    {
        for (S i = 0; i < n; ++first, (void)++i)
            f(*first);
        return first;
    }

    template <typename It, typename T>
    constexpr typename iterator_traits<It>::difference_type count(It first, It last, const T& value)
    {
        typename iterator_traits<It>::difference_type ret = 0;
        for (; first != last; ++first)
            if (*first == value)
                ret++;
        return ret;
    }

    template <typename It, typename F>
    constexpr typename iterator_traits<It>::difference_type count_if(It first, It last, F p)
    {
        typename iterator_traits<It>::difference_type ret = 0;
        for (; first != last; ++first)
            if (p(*first))
                ret++;
        return ret;
    }

    /*template <typename It1, typename It2>
    std::pair<It1, It2> mismatch(It1 first1, It1 last1, It2 first2)
    {
        while (first1 != last1 && *first1 == *first2)
        {
            ++first1, ++first2;
        }
        return std::make_pair(first1, first2);
    }

    template <typename InputIt1, typename InputIt2, typename F>
    std::pair<InputIt1, InputIt2> mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, F p)
    {
        while (first1 != last1 && p(*first1, *first2))
        {
            ++first1, ++first2;
        }
        return std::make_pair(first1, first2);
    }

    template <typename InputIt1, typename InputIt2>
    std::pair<InputIt1, InputIt2> mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2)
    {
        while (first1 != last1 && first2 != last2 && *first1 == *first2)
        {
            ++first1, ++first2;
        }
        return std::make_pair(first1, first2);
    }

    template <typename InputIt1, typename InputIt2, typename F>
    std::pair<InputIt1, InputIt2> mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                                           F p)
    {
        while (first1 != last1 && first2 != last2 && p(*first1, *first2))
        {
            ++first1, ++first2;
        }
        return std::make_pair(first1, first2);
    }*/

    template <typename It, typename T>
    constexpr It find(It first, It last, const T& value)
    {
        for (; first != last; ++first)
            if (*first == value)
                return first;
        return last;
    }

    template <typename It, typename P>
    constexpr It find_if(It first, It last, P p)
    {
        for (; first != last; ++first)
            if (p(*first))
                return first;
        return last;
    }

    template <typename It, typename P>
    constexpr It find_if_not(It first, It last, P q)
    {
        for (; first != last; ++first)
            if (!q(*first))
                return first;
        return last;
    }

    template <typename It, typename P>
    constexpr bool all_of(It first, It last, P p)
    {
        return std::find_if_not(first, last, p) == last;
    }

    template <typename It, typename P>
    constexpr bool any_of(It first, It last, P p)
    {
        return std::find_if(first, last, p) != last;
    }

    template <typename It, typename P>
    constexpr bool none_of(It first, It last, P p)
    {
        return std::find_if(first, last, p) == last;
    }

    template <typename It1, typename It2>
    constexpr It1 search(It1 first, It1 last, It2 s_first, It2 s_last)
    {
        while (1)
        {
            It1 it = first;
            for (It2 s_it = s_first;; ++it, ++s_it)
            {
                if (s_it == s_last)
                    return first;
                if (it == last)
                    return last;
                if (!(*it == *s_it))
                    break;
            }
            ++first;
        }
    }

    template <typename It1, typename It2, typename F>
    constexpr It1 search(It1 first, It1 last, It2 s_first, It2 s_last, F p)
    {
        while (1)
        {
            It1 it = first;
            for (It2 s_it = s_first;; ++it, ++s_it)
            {
                if (s_it == s_last)
                    return first;
                if (it == last)
                    return last;
                if (!p(*it, *s_it))
                    break;
            }
            ++first;
        }
    }

    template <typename It1, typename It2>
    constexpr It1 find_end(It1 first, It1 last, It2 s_first, It2 s_last)
    {
        if (s_first == s_last)
            return last;
        It1 result = last;
        while (true)
        {
            It1 new_result = std::search(first, last, s_first, s_last);
            if (new_result == last)
                break;
            else
            {
                result = new_result;
                first = result;
                ++first;
            }
        }
        return result;
    }

    template <typename It1, typename It2, typename F>
    constexpr It1 find_end(It1 first, It1 last, It2 s_first, It2 s_last, F p)
    {
        if (s_first == s_last)
            return last;
        It1 result = last;
        while (true)
        {
            It1 new_result = std::search(first, last, s_first, s_last, p);
            if (new_result == last)
                break;
            else
            {
                result = new_result;
                first = result;
                ++first;
            }
        }
        return result;
    }

    template <typename It1, typename It2>
    It1 find_first_of(It1 first, It1 last, It2 s_first, It2 s_last)
    {
        for (; first != last; ++first)
            for (It2 it = s_first; it != s_last; ++it)
                if (*first == *it)
                    return first;
        return last;
    }

    template <typename InputIt, typename ForwardIt, typename F>
    InputIt find_first_of(InputIt first, InputIt last, ForwardIt s_first, ForwardIt s_last, F p)
    {
        for (; first != last; ++first)
        {
            for (ForwardIt it = s_first; it != s_last; ++it)
            {
                if (p(*first, *it))
                {
                    return first;
                }
            }
        }
        return last;
    }
    template <typename ForwardIt>
    ForwardIt adjacent_find(ForwardIt first, ForwardIt last)
    {
        if (first == last)
        {
            return last;
        }
        ForwardIt next = first;
        ++next;
        for (; next != last; ++next, ++first)
        {
            if (*first == *next)
            {
                return first;
            }
        }
        return last;
    }

    template <typename ForwardIt, typename F>
    ForwardIt adjacent_find(ForwardIt first, ForwardIt last, F p)
    {
        if (first == last)
        {
            return last;
        }
        ForwardIt next = first;
        ++next;
        for (; next != last; ++next, ++first)
        {
            if (p(*first, *next))
            {
                return first;
            }
        }
        return last;
    }

    template <typename ForwardIt, typename Size, typename T>
    ForwardIt search_n(ForwardIt first, ForwardIt last, Size count, const T& value)
    {
        if (count <= 0)
        {
            return first;
        }
        for (; first != last; ++first)
        {
            if (!(*first == value))
            {
                continue;
            }

            ForwardIt candidate = first;
            Size cur_count = 0;

            while (true)
            {
                ++cur_count;
                if (cur_count >= count)
                {
                    // success
                    return candidate;
                }
                ++first;
                if (first == last)
                {
                    // exhausted the list
                    return last;
                }
                if (!(*first == value))
                {
                    // too few in a row
                    break;
                }
            }
        }
        return last;
    }

    template <typename ForwardIt, typename Size, typename T, typename F>
    ForwardIt search_n(ForwardIt first, ForwardIt last, Size count, const T& value, F p)
    {
        if (count <= 0)
        {
            return first;
        }
        for (; first != last; ++first)
        {
            if (!p(*first, value))
            {
                continue;
            }

            ForwardIt candidate = first;
            Size cur_count = 0;

            while (true)
            {
                ++cur_count;
                if (cur_count >= count)
                {
                    // success
                    return candidate;
                }
                ++first;
                if (first == last)
                {
                    // exhausted the list
                    return last;
                }
                if (!p(*first, value))
                {
                    // too few in a row
                    break;
                }
            }
        }
        return last;
    }

    template <typename InputIt, typename OutputIt>
    OutputIt copy(InputIt first, InputIt last, OutputIt d_first)
    {
        for (; first != last; (void)++first, (void)++d_first)
        {
            *d_first = *first;
        }
        return d_first;
    }

    template <typename InputIt, typename OutputIt, typename UnaryPredicate>
    OutputIt copy_if(InputIt first, InputIt last, OutputIt d_first, UnaryPredicate pred)
    {
        for (; first != last; ++first)
        {
            if (pred(*first))
            {
                *d_first = *first;
                ++d_first;
            }
        }
        return d_first;
    }

    template <typename InputIt, typename Size, typename OutputIt>
    constexpr OutputIt copy_n(InputIt first, Size count, OutputIt result)
    {
        if (count > 0)
        {
            *result++ = *first;
            for (Size i = 1; i < count; ++i)
            {
                *result++ = *++first;
            }
        }
        return result;
    }

    template <typename BidirIt1, typename BidirIt2>
    BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
    {
        while (first != last)
        {
            *(--d_last) = *(--last);
        }
        return d_last;
    }

    template <typename InputIt, typename OutputIt>
    OutputIt move(InputIt first, InputIt last, OutputIt d_first)
    {
        while (first != last)
        {
            *d_first++ = std::move(*first++);
        }
        return d_first;
    }

    template <typename BidirIt1, typename BidirIt2>
    BidirIt2 move_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
    {
        while (first != last)
        {
            *(--d_last) = std::move(*(--last));
        }
        return d_last;
    }
    template <typename ForwardIt, typename T>
    void fill(ForwardIt first, ForwardIt last, const T& value)
    {
        for (; first != last; ++first)
        {
            *first = value;
        }
    }

    template <typename OutputIt, typename Size, typename T>
    OutputIt fill_n(OutputIt first, Size count, const T& value)
    {
        for (Size i = 0; i < count; i++)
        {
            *first++ = value;
        }
        return first;
    }

    template <typename InputIt, typename OutputIt, typename UnaryOperation>
    OutputIt transform(InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op)
    {
        while (first1 != last1)
        {
            *d_first++ = unary_op(*first1++);
        }
        return d_first;
    }

    template <typename InputIt1, typename InputIt2, typename OutputIt, typename BinaryOperation>
    OutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOperation binary_op)
    {
        while (first1 != last1)
        {
            *d_first++ = binary_op(*first1++, *first2++);
        }
        return d_first;
    }

    template <typename ForwardIt, typename Generator>
    constexpr // Since C++20
        void
        generate(ForwardIt first, ForwardIt last, Generator g)
    {
        while (first != last)
        {
            *first++ = g();
        }
    }

    template <typename OutputIt, typename Size, typename Generator>
    constexpr    // since C++20
        OutputIt // void until C++11
        generate_n(OutputIt first, Size count, Generator g)
    {
        for (Size i = 0; i < count; ++i)
        {
            *first++ = g();
        }
        return first;
    }

    template <typename ForwardIt, typename T>
    ForwardIt remove(ForwardIt first, ForwardIt last, const T& value)
    {
        first = std::find(first, last, value);
        if (first != last)
            for (ForwardIt i = first; ++i != last;)
                if (!(*i == value))
                    *first++ = std::move(*i);
        return first;
    }

    template <typename ForwardIt, typename UnaryPredicate>
    ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p)
    {
        first = std::find_if(first, last, p);
        if (first != last)
            for (ForwardIt i = first; ++i != last;)
                if (!p(*i))
                    *first++ = std::move(*i);
        return first;
    }

    template <typename InputIt, typename OutputIt, typename T>
    OutputIt remove_copy(InputIt first, InputIt last, OutputIt d_first, const T& value)
    {
        for (; first != last; ++first)
        {
            if (!(*first == value))
            {
                *d_first++ = *first;
            }
        }
        return d_first;
    }

    template <typename InputIt, typename OutputIt, typename UnaryPredicate>
    OutputIt remove_copy_if(InputIt first, InputIt last, OutputIt d_first, UnaryPredicate p)
    {
        for (; first != last; ++first)
        {
            if (!p(*first))
            {
                *d_first++ = *first;
            }
        }
        return d_first;
    }

    template <typename ForwardIt, typename T>
    void replace(ForwardIt first, ForwardIt last, const T& old_value, const T& new_value)
    {
        for (; first != last; ++first)
        {
            if (*first == old_value)
            {
                *first = new_value;
            }
        }
    }

    template <typename ForwardIt, typename UnaryPredicate, typename T>
    void replace_if(ForwardIt first, ForwardIt last, UnaryPredicate p, const T& new_value)
    {
        for (; first != last; ++first)
        {
            if (p(*first))
            {
                *first = new_value;
            }
        }
    }

    template <typename InputIt, typename OutputIt, typename T>
    OutputIt replace_copy(InputIt first, InputIt last, OutputIt d_first, const T& old_value, const T& new_value)
    {
        for (; first != last; ++first)
        {
            *d_first++ = (*first == old_value) ? new_value : *first;
        }
        return d_first;
    }

    template <typename InputIt, typename OutputIt, typename UnaryPredicate, typename T>
    OutputIt replace_copy_if(InputIt first, InputIt last, OutputIt d_first, UnaryPredicate p, const T& new_value)
    {
        for (; first != last; ++first)
        {
            *d_first++ = p(*first) ? new_value : *first;
        }
        return d_first;
    }

    template <typename BidirIt, typename OutputIt>
    constexpr OutputIt reverse_copy(BidirIt first, BidirIt last, OutputIt d_first)
    {
        while (first != last)
        {
            *(d_first++) = *(--last);
        }
        return d_first;
    }
} // namespace std

#endif
