// vim: ft=cpp
#ifndef __NOSTDLIB_UTILITY_H__
#define __NOSTDLIB_UTILITY_H__

#include "../bits/declval.h"
#include "../bits/pair.h"
#include "../bits/utils.h"
#include <type_traits>

namespace std
{
    namespace detail
    {
#if __has_builtin(__type_pack_element)
        template <size_t N, typename... Ts>
        struct type_pack_element
        {
            using type = __type_pack_element<N, Ts...>;
        };
#else
        template <size_t N, typename... Ts>
        struct type_pack_element;

        template <size_t N, typename T, typename... Ts>
        struct type_pack_element<N, T, Ts...> : type_pack_element<N - 1, Ts...>
        {
        };

        template <typename T, typename... Ts>
        struct type_pack_element<0, T, Ts...>
        {
            using type = T;
        };
#endif

    } // namespace detail
    // template <typename T>
    // void swap(T& a, T& b) noexcept(false);

    // template <typename T2, size_t N>
    // void swap(T2 (&a)[N], T2 (&b)[N]) noexcept(/* see below */);

    template <typename T>
    constexpr T&& forward(remove_reference_t<T>& t) noexcept
    {
        return static_cast<T&&>(t);
    }

    template <typename T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept
    {
        static_assert(!is_lvalue_reference_v<T>, "Can not forward an rvalue as an lvalue.");
        return static_cast<T&&>(t);
    }

    template <typename T>
    remove_reference_t<T>&& move(T&& arg)
    {
        return static_cast<remove_reference_t<T>&&>(arg);
    }

    template <typename T, typename U = T>
    constexpr T exchange(T& obj, U&& new_value)
    {
        T old_value = move(obj);
        obj = forward<U>(new_value);
        return old_value;
    }

    template <typename T>
    constexpr conditional_t<!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value, const T&, T&&>
    move_if_noexcept(T& x) noexcept
    {
        return static_cast<
            conditional_t<!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value, const T&, T &&>>(x);
    };

    struct in_place_t
    {
        explicit in_place_t() = default;
    };
    inline constexpr in_place_t in_place{};
    template <class T>
    struct in_place_type_t
    {
        explicit in_place_type_t() = default;
    };
    template <class T>
    inline constexpr in_place_type_t<T> in_place_type{};
    template <size_t I>
    struct in_place_index_t
    {
        explicit in_place_index_t() = default;
    };

    template <size_t I>
    inline constexpr in_place_index_t<I> in_place_index{};

    namespace detail
    {
        template <class T>
        constexpr T& FUN(T& t) noexcept
        {
            return t;
        }
        template <class T>
        void FUN(T&&) = delete;
    } // namespace detail

    template <class T>
    class reference_wrapper
    {
    public:
        // types
        typedef T type;

        // construct/copy/destroy
        template <class U, class = decltype(detail::FUN<T>(std::declval<U>()),
                                            std::enable_if_t<!std::is_same_v<reference_wrapper, std::remove_cvref_t<U>>>())>
        constexpr reference_wrapper(U&& u) noexcept(noexcept(detail::FUN<T>(std::forward<U>(u))))
            : _ptr(std::addressof(detail::FUN<T>(std::forward<U>(u))))
        {
        }
        reference_wrapper(const reference_wrapper&) noexcept = default;

        // assignment
        reference_wrapper& operator=(const reference_wrapper& x) noexcept = default;

        // access
        constexpr operator T&() const noexcept { return *_ptr; }
        constexpr T& get() const noexcept { return *_ptr; }

        template <class... ArgTypes>
        constexpr std::invoke_result_t<T&, ArgTypes...> operator()(ArgTypes&&... args) const
        {
            return std::invoke(get(), std::forward<ArgTypes>(args)...);
        }

    private:
        T* _ptr;
    };

    // deduction guides
    template <class T>
    reference_wrapper(T&) -> reference_wrapper<T>;

    template <typename T1, typename T2>
    constexpr auto make_pair(T1&& t, T2&& u);

    namespace detail
    {
        template <typename T>
        struct strip_reference_wrapper
        {
            typedef T type;
        };

        template <typename T>
        struct strip_reference_wrapper<reference_wrapper<T>>
        {
            typedef T& type;
        };

        template <typename T>
        using decay_and_strip = typenae strip_reference_wrapper<decay_t<T>>::type;
    } // namespace detail

    template <typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> make_pair(_T1&& __x,
                                                                                                               _T2&& __y)
    {
        typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        typedef pair<__ds_type1, __ds_type2> __pair_type;
        return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
} // namespace std

#endif
